# -*- mode: org; -*-

#+begin_src emacs-lisp :results none :export none
  (org-babel-tangle-file "README.org")
#+end_src

Le dossier contient les données du séquençage des deux plaques envoyées à la
suite des manips d'Anne-Laure. 

* Tâches [6/7]
- [X] écrire le script qui filtre les données sur la qualité
- [X] comparer fastqc output
- [X] refaire le SNP calling
- [X] réécrire les étapes pour arriver au SNP calling
- [X] faire un SQL join dans R pour matcher query name et seq id.
- [X] analyser les données de SNP
- [ ] préparer résultats vendredi <2015-11-20 Fri 10:00> 

* structure
#+BEGIN_SRC sh :results verbatim 
tree ./ -L 2
#+END_SRC

#+begin_src
./
|-- README.org
|-- analysis
|   |-- plots
|   |-- snp_distribution.pdf
|   |-- snp_resume.pdf
|   |-- substitution_distribution.pdf
|   |-- trimmed_fastqc.html
|   |-- untrimmed_fastqc.html
|   `-- vincent_plot.pdf
|-- data
|   |-- 1369607.INDEL.csv
|   |-- 1369607.SNP.csv
|   |-- 1369628.INDEL.csv
|   |-- 1369628.SNP.csv
|   |-- Analysis_Summary-Sanger_Pipeline.pdf
|   |-- all.fasta
|   |-- fasta
|   |-- fastq
|   |-- id_table.dat
|   |-- raw_seq_nvbr
|   |-- reference.fasta
|   |-- refseq.fasta
|   |-- refseq_reverse.fasta
|   |-- seq
|   |-- spectrograms
|   |-- strong.csv
|   |-- tmp
|   |-- trimmed.fasta
|   |-- trimmed.fastq
|   |-- untrimmed.fastq
|   `-- variantCalling
`-- scripts
    |-- ab1_parser.py
    |-- ab1_to_fastq
    |-- exploratory_analysis.R
    |-- extract_raw_data.sh
    |-- make_id_table.py
    |-- quality_check
    |-- quality_trim.R
    |-- trim_low_quality.sh
    |-- variantCallerBwa.sh
    |-- variantCallerSsaha2.sh
    `-- variant_analysis.R

11 directories, 32 files
#+end_src

| dossier  | fichier ou dossier                      | description                                                                 |
|----------+-----------------------------------------+-----------------------------------------------------------------------------|
| analysis |                                         |                                                                             |
|          | -- plots                                | dossier contenant les différents plots générés par plots-bcftools.          |
|          | -- snp_distribution.pdf                 | la distribution des SNP sans tenir compte de la provenance des mutants      |
|          | -- snp_resume.pdf                       | les trois plots sur la même feuille                                         |
|          | -- substitution_distribution.pdf        | la distribution des substitutions.                                          |
|          | -- trimmed_fastqc.html                  | le contrôle de la qualité des séquences trimmées via fastqc                 |
|          | -- untrimmed_fastqc.html                | le contrôle de la qualité des séquences non-trimmées via fastqc             |
|          | -- vincent_plot.pdf                     | le graphe de vincent le jour de la réception des données.                   |
|----------+-----------------------------------------+-----------------------------------------------------------------------------|
| data     |                                         |                                                                             |
|          | -- 1369607.INDEL.csv                    | le fichier envoyé par GATK                                                  |
|          | -- 1369607.SNP.csv                      | le fichier envoyé par GATK                                                  |
|          | -- 1369628.INDEL.csv                    | le fichier envoyé par GATK                                                  |
|          | -- 1369628.SNP.csv                      | le fichier envoyé par GATK                                                  |
|          | -- Analysis_Summary-Sanger_Pipeline.pdf | description du fichier d'analyse GATK                                       |
|          | -- all.fasta                            | toutes les séquences                                                        |
|          | -- fasta                                | dossier contenant les séquences une à une                                   |
|          | -- fastq                                | idem en fastq                                                               |
|          | -- id_table.dat                         | une table contenant les nom de séquence, le mutant, et la qualité du mutant |
|          | -- raw_seq_nvbr                         | le dossier contenant les données brutes                                     |
|          | -- reference.fasta                      | la séquence de référence                                                    |
|          | -- refseq.fasta                         | idem                                                                        |
|          | -- refseq_reverse.fasta                 | la séquence de référence reversed.                                          |
|          | -- seq                                  | le dossier contentant les séquneces                                         |
|          | -- spectrograms                         | le dossier contentant les .ab1 files                                        |
|          | -- tmp                                  | un dossier de travail                                                       |
|          | -- trimmed.fasta                        | les séquences trimmées                                                      |
|          | -- trimmed.fastq                        | idem                                                                        |
|          | -- untrimmed.fastq                      | les séquences non trimmées                                                  |
|          | -- variantCalling                       | le dossier de travail pour l'analyse des variants                           |
|----------+-----------------------------------------+-----------------------------------------------------------------------------|
| scripts  |                                         |                                                                             |
|          | -- ab1_parser.py                        | convertit l'ensemble des fichiers .ab1 en fastq                             |
|          | -- ab1_to_fastq                         | idem, utilitaire pipeable                                                   |
|          | -- exploratory_analysis.R               | premières analyses dans R                                                   |
|          | -- extract_raw_data.sh                  | met en place la structure de données                                        |
|          | -- make_id_table.py                     | crée le fichier ../data/id_table.dat                                        |
|          | -- quality_check                        | analyse la qualité via fastqc                                               |
|          | -- trim_low_quality.sh                  | trimme les séquences via bbduk                                              |
|          | -- variantCallerBwa.sh                  | un premier essai d'alignement et de snp calling via samtools et bcftools    |
|          | -- variantCallerSsaha2.sh               | l'alignement avec ssaha2SNP                                                 |
|          | -- variant_analysis.R                   | l'analyse des variants et les graphes qui vont avec                         |

* Commentaires
** [2015-11-09 Mon]
Pas de données dans le fichier [[./data/fasta/pS6-1073.fas]], mais pourtant le
fichier [[./data/spectrograms/pS6-1073.ab1]] en contient. On repart des .ab1 avec un
script [[./scripts/ab1_parser.py]], qui convertit les .ab1 en fasta et fastq. 

Le fichier [[./data/fasta/pS6-1073.fst]] est toujours aussi mauvais. Erreurs de
séquençage ? À exclure des analyses. 

Le fichier [[./data/fasta/pS9-1073.fst]] a un indel en position 343-342 et en
position 397. Au vu du spectrogramme [[./data/spectrograms/pS9-1073.ab1]], c'est une
erreur de séquençage. Globalement, qualité du séquençage pas très bonne. À
exclure des analyses.
** [2015-11-16 Mon]
La semaine dernière, le script [[./scripts/ab1_parser.py]] convertissait tous les
spectrograms de =ab1= vers =fastq=. Combiné en 1 fichier, =all.fastq=, on a
utilisé /fastqc/ pour avoir une idée de la qualité. Le résultat dans
[[./analysis/all_fastqc.html]]. Il a été convenu arbitrairement avec Vincent que les bases d'une
qualité < 28 seraient exclues de l'analyse. Aujourd'hui, le script
[[./scripts/ab1_parser.py]] va être modifié en conséquence. Voir les anciennes
versions via /git/ éventuellement.

J'écris également aujourd'hui le script [[./scripts/trim_low_quality.py]], qui
enlève les 30 premières et dernières séquences, et qui empêche les séquences de
trop mauvaise qualité d'être utilisées dans l'analyse. 

Finalement, inutile de réinventer la roue. =Fastx_toolkit= devrait normalement
faire ça très bien, mais ça ne fonctionne pas, pour des raisons que je ne
m'explique pas. Cependant, je suis tombé sur l'utilitaire =BBmap=, qui contient
entre autre, =bbduk=. [[~/.bin/bbmap/bbduk.sh][Voir le fichier source ici]], la page de téléchargement [[http://sourceforge.net/projects/bbmap/?source=typ_redirect][là]],
et pour des commentaires sur l'utilisation [[http://seqanswers.com/forums/showthread.php?t=58221][Voir là]], et [[http://seqanswers.com/forums/showthread.php?t=42776][là]].

** [2015-11-17 Tue]
Je supprime donc le script =low_quality_trim.py=. J'utilise le script
=low_quality_trim.sh=. 

En résultat, comparer [[./analysis/trimmed_fastqc.html]] et
[[./analysis/untrimmed_fastqc.html]]. On n'a plus que 179 séquences au lieu de 192,
mais ça vaut le coup, la qualité est largement supérieure. 

Je veux maintenant déterminer les SNPs. Il faut donc que j'aligne les séquences
obtenues avec la séquence de référence [[./data/refseq.fasta]]. GATC utilise le
software =SSAHA2= (voir [[http://www.sanger.ac.uk/science/tools/ssaha2-0][là]]) mais à priori il n'est plus utilisable. Le site
recommande d'utiliser =SMALT=, (voir la page de téléchargement [[http://sourceforge.net/projects/smalt/?source=typ_redirect][là]], le manuel [[ftp://ftp.sanger.ac.uk/pub/resources/software/smalt/smalt-manual-0.7.4.pdf][là]]
et la page du software [[http://www.sanger.ac.uk/science/tools/smalt-0][là]]. 

En fait, je l'ai juste installé comme ça :

#+BEGIN_SRC sh
brew update
brew tap homebrew/homebrew-science
brew install smalt
#+END_SRC

Finalement, c'est encore un autre workflow que je veux adopter. On repart sur
=ssaha2= et =ssaha2SNP=, la page de téléchargement étant
[[ftp://ftp.sanger.ac.uk/pub/resources/software/ssaha2/]].  

** [2015-11-18 Wed]
Il faut clarifier les étapes permettant d'aligner et de déterminer les SNP. Ce
qui est fait dans le script [[./scripts/variantCallerSsaha2.sh]]. 
* data
** raw_seq_nvbr
Contient les deux dataset au format .zip. DO NOT TOUCH.
** extraction des données
Pour extraire les données du fichier brut .zip à la structure de données.

#+BEGIN_SRC sh :tangle ./scripts/extract_raw_data.sh 
  #!/bin/bash 

  # Le script qui extrait les données depuis les fichiers zip bruts et qui met en
  # place la structure de fichier.

  cd ./data # à modifier en cd ../data quand dans dossier `scripts'
  # extraction des données brutes
  unzip raw_seq_nvbr/1369607.zip
  unzip raw_seq_nvbr/1369628.zip
  # déplace tout les fichiers dans des dossiers adaptés 
  find . -name "*.fas" -exec mv -i {} -t ./fasta/ \;
  find . -name "*.ab1" -exec mv -i {} -t ./spectrograms/ \;
  find . -name "*.seq" -exec mv -i {} -t ./seq/ \;
  # déplace le contenu du dossier inutile dans le présent dossier
  mv 1369628/* ./
  rm -r 1369628 # supprime le dossier

  ##
  ## supprime fichiers mauvaise qualité
  ##
  # absence de données dans pS6-1073.fas
  # on repart des données de .ab1
  rm ./fasta/*.fas

  ##
  ## combine tout les fasta en 1
  ##
  if [ -f all.fasta ]
  then
      rm all.fasta
      echo "Cleaning old files"
      touch all.fasta
  else
      touch all.fasta
  fi

  cat ../data/fasta/*.fst >> ../data/all.fasta
#+END_SRC
* analysis 
Contient les résultats des analyses. Graphes ou données transformées. 
* scripts 
Contient les différents scripts nécessaires pour aboutir aux contenus
d'~analysis~. 

** Analyses préliminaires des csv 
#+BEGIN_SRC R :tangle ./scripts/exploratory_analysis.R 
  library(dplyr)
  library(ggplot2)

  read_result <- function(filename){
    readr::read_delim(filename, delim = ";")
  }

  snp_strong   <- read_result("./data/1369628.SNP.csv")
  snp_weak   <- read_result("./data/1369607.SNP.csv")
  indel_strong <- read_result("./data/1369628.INDEL.csv")
  indel_weak <- read_result("./data/1369607.INDEL.csv")
  snp_weak$mutant <- "weak"
  snp_strong$mutant <- "strong"

#+END_SRC
** ab1 -> (fastq , fasta)
*** d'un seul coup
C'est un script python qui convertit les fichiers .ab1 du dossier
[[./data/spectrograms/]]  en fichier .fastq, dans le dossier [[./data/fastq/]].  

1. lit les fichiers du dossier contenant .ab1
2. les transforme en fastq
3. écriture sur le disque dans le dosssier fastq.

#+BEGIN_SRC python :tangle ./scripts/ab1_parser.py
  #!/usr/bin/env python
  import os
  from Bio import SeqIO

  # lit tout les fichiers du dossier spectrogram
  for file_name in os.listdir("../data/spectrograms/"):
      # check if it ends with .ab1
      if file_name.endswith(".ab1"):
          print("parsing sequences from " + file_name)

          ab1_in = "../data/spectrograms/" + file_name
          fastq_out = "../data/fastq/" + file_name[0:-4] + ".fastq"
          fasta_out = "../data/fasta/" + file_name[0:-4] + ".fst"
          # convert the file
          SeqIO.convert(ab1_in, "abi", fastq_out, "fastq")
          SeqIO.convert(ab1_in, "abi", fasta_out, "fasta")

#+END_SRC

*** from stdin
#+BEGIN_SRC python :tangle ./scripts/ab1_to_fastq
  #!/usr/bin/env python
  """
  ============
  ab1_to_fastq
  ============

  Un module pour convertir le fichier .ab1 en fichier fastq.
  À noter que le stdin en question doit être une liste de nom de fichiers
  ab1. 

  Example:
  ls | grep ab1 | ab1_to_fastq
  """

  from __future__ import print_function
  import sys
  from Bio import SeqIO

  for line in sys.stdin:
      assert line.rstrip().endswith(".ab1"), "not an ab1 file"
      with open(line.rstrip(), "rb") as ab1_file:
          ab1_record = SeqIO.read(ab1_file, "abi")
          print(ab1_record.format("fastq"))

#+END_SRC

** untrimmed.fastq -> trimmed.fastq
Un script qui convertit le fichier [[./data/untrimmed.fastq]] en fichier [[./data/trimmed.fastq]]

#+BEGIN_SRC sh :tangle ./scripts/trim_low_quality.sh
  #!/usr/local/bin/bash

  #' -qtrim=rl : quality trim right and left 
  #' -trimq=28 : trim if quality < 28 (sanger encoding, illumina 1.9)
  #' -minlen=620 : keep only seq with length > 620, after trimming.
  #' -Xmx1g : tells bbduk to use 1G of RAM

  if [[ -f ../data/untrimmed.fastq && ! -f ../data/trimmed.fastq ]]; then # seulement si les fichiers n'existent pas. 
      ~/.bin/bbmap/bbduk.sh -Xmx1g -in=../data/untrimmed.fastq -out=../data/trimmed.fastq qtrim=rl trimq=28 -minlen=620
  else
      rm ../data/trimmed.fastq
      rm ../data/untrimmed.fastq
      ./quality_check # assemble tous les fichiers .fastq de novo
      ~/.bin/bbmap/bbduk.sh -Xmx1g -in=../data/untrimmed.fastq -out=../data/trimmed.fastq qtrim=rl trimq=28 -minlen=620
  fi

  fastqc trimmed.fastq -o ./tmp
  mv ./tmp/trimmed_fastqc.html ../analysis
#+END_SRC
** quality check : analyses fastqc
Le script utilisé pour analyser les données de qualité via /fastqc/. 

#+BEGIN_SRC sh :tangle scripts/quality_check
  #!/usr/local/bin/bash
  # quand dans le dossier ./scripts
  cd ../data/

  if [ -f untrimmed.fastq ]; then # si le dossier tmp existe
      rm untrimmed.fastq
      cat fastq/*.fastq > untrimmed.fastq
  else
      cat fastq/*.fastq > untrimmed.fastq
  fi

  fastqc untrimmed.fastq -o ./tmp # analyse les données et output dans tmp
  mv ./tmp/untrimmed_fastqc.html ../analysis/ # déplace dans le dossier résultat.
#+END_SRC 
** variant calling

#+name: Prérequis
#+BEGIN_SRC sh
  brew tap homebrew/homebrew-science
  brew update
  brew install samtools bamtools bcftools bwa
#+END_SRC

Clairement pas la bonne façon de s'y prendre. 
#+BEGIN_SRC sh :tangle ./scripts/variantCallerBwa.sh
  #!/bin/bash

  # le but est de déterminer les SNP
  # le workflow suivi est celui décrit là http://www.htslib.org/workflow/. 

  ## working dir
  cd ../data
  mkdir variantCalling

  ## utilise le reverse complement de la séquence de référence
  fastx_reverse_complement -i refseq.fasta -o refseq_reverse.fasta
  cp refseq_reverse.fasta variantCalling/
  cp trimmed.fastq variantCalling/

  cd variantCalling
  # renome en utilisant un nom plus simple
  mv refseq_reverse.fasta reference.fasta
  ## indexation du fichier référence
  bwa index reference.fasta
  # alignement au fichier de reference
  #' * aln : align
  #' * mem : algo bwa-mem, more accurate with reads > 100bp. 
  #' * reference.fasta : reference sequence
  #' * trimmed.fastq : sequence trimmee.
  #' * aln_sa.sai : fichier aligné indexé
  bwa mem reference.fasta trimmed.fastq > align.sam

  ## sort from name order to coordinate order
  #' * sort : sorting algorithm
  #' * -O bam : output to bam
  #' * -o align.bam : name of output
  #' * -T ./tmp/align_temp : name of temp file
  #' * align.sam : fichier en entrée
  mkdir tmp
  samtools sort -O bam -o align.bam -T ./tmp/align_temp align.sam

  ## conversion au format sam
  #' * samse : sam singled end
  #' * reference.fasta : reference sequence
  #' * aln_sa.sai : alignement indexé
  # bwa samse reference.fasta aln_sa.sai trimmed.fastq > aln.sam

  ## variant calling
  #'
  #'
  samtools mpileup -ugf reference.fasta align.bam | \
      bcftools call -vmO z -o study.vcf.gz

  ## indexation du VCF
  tabix -p vcf study.vcf.gz

  ## graphes et statistiques
  bcftools stats -F reference.fasta -s - study.vcf.gz > study.vcf.gz.stats
  mkdir plots
  plot-vcfstats -p plots/ study.vcf.gz.stats
  ## déplace dans le dossier analyses
  cp -r plots ../../analysis/
#+END_SRC

#+BEGIN_SRC sh :tangle ./scripts/variantCallerSsaha2.sh
  #!/bin/bash

  # variant calling using ssaha2 and ssaha2SNP

  cd ../data/variantCalling
  cp ../trimmed.fastq .
  ln -s ../refseq_reverse.fasta ./reference.fasta
  ## alignement à la séquence de référence
  #' * -output psl : format de sortie psl
  #' * reference.fasta : séquence de référence
  #' * trimmed.fastq : séquence à aligner
  #' * output.psl : fichier de sortie
  ~/.bin/ssahaSNP/ssaha2 -output psl reference.fasta trimmed.fastq > output.psl

  ## polymorphism detection tool
  ~/.bin/ssahaSNP/ssaahaSNP reference.fasta trimmed.fastq > SNP.txt

  ## computer readable format conversion
  egrep ssaha:SNP SNP.txt | awk '{print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15}' >  SNP.dat

  ## column annotation based on ftp://ftp.sanger.ac.uk/pub/resources/software/ssahasnp/readme,
  ## part (6) some further information
  echo " match subject_name index_of_subject read_name s_base q_base s_qual q_qual offset_on_subject offset_on_read length_of_snp start_match_of_read end_match_of_read match_direction length_of_subject " > head.dat
  # into final document
  cat head.dat SNP.dat > snp_calling.dat
#+END_SRC

** variant analysis

*** make id - query table
Les spectrogrammes contiennent l'info de la sequence_id et du nom. 
On construit une table avec la qualité du mutant en troisième colonne. 
#+BEGIN_SRC python :tangle ./scripts/make_id_table.py
  from Bio import SeqIO
  import glob

  def mutant_qualifier(record):
      if 'S' in record:
          return 'strong'
      else:
          return 'weak'

  print "id name mutant"
  for file in glob.glob("../data/spectrograms/*.ab1"):
      with open(file, "rb") as spectro:
          for record in SeqIO.parse(spectro, "abi"):
              print record.id + " " + record.name + \
                  " " + mutant_qualifier(record.name)
#+END_SRC

On crée la table en question avec :
#+BEGIN_SRC sh
  cd ./scripts/
  python make_id_table.py > ../data/id_table.dat
#+END_SRC

*** analysis
#+BEGIN_SRC R :tangle ./scripts/variant_analysis.R
  setwd("~/stage/seq_novembre/data/variantCalling")

  library(dplyr)
  library(ggplot2)
  library(extrafont)
  library(ggthemes)
  library(cowplot)

  ##

  mytheme <- theme(panel.ontop = TRUE,
                   axis.text = element_text(size = 8, colour = "gray"),
                   panel.grid.major.x = element_blank(),
                   panel.grid.minor.x = element_blank(),
                   panel.grid.minor.y = element_blank(),
                   panel.grid.major.y = element_line(colour = "white", size = 1)) 

  ## read the data
  snp <- tbl_df(read.table("snp_calling.dat", head = TRUE))
  ## enlève les colonnes inutiles
  snp %>%
      select( -match, -subject_name, -index_of_subject, -length_of_subject,
             -match_direction) ->
      snp
  ## lit les métadonnées de séquence
  id_table <- tbl_df(read.table("../id_table.dat", head = TRUE))

  ## fait correspondre le read_name avec le nom du clone et le type de mutant W ou S
  snp_data <- inner_join(x = snp, y = id_table, by = c("read_name" = "id"))

  ##==============================================================================
  ## PLOT DISTRIBUTIONS
  ##==============================================================================
  snp_plot <- ggplot(data = snp_data, aes(offset_on_subject)) +
      geom_density(aes(fill = mutant), alpha = 0.2) +
      geom_histogram(aes(fill = mutant),
                     binwidth = 10, position = "dodge") +
      theme_minimal(base_family = "Courier") +
      ## scale_y_tufte() +
      scale_x_continuous(breaks = seq(1, 734, 30)) +
      scale_fill_brewer(palette = "Set1") +
      xlab("Distribution des SNP sur le gene sauvage") +
      ylab("") +
      theme(panel.ontop = TRUE,
            legend.position = c(0.2, 0.6),
            axis.text = element_text(size = 8, colour = "gray"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor.x = element_blank(),
            panel.grid.minor.y = element_blank(),
            panel.grid.major.y = element_line(colour = "white", size = 1)) 


  #' une fonction pour déterminer si la substitution est strong ou weak. On peut
  #' avoir des substitutions weak chez les strongs
  #' @param subject la base sur la séquence de référence
  #' @param query la base sur le read.
  mutant_caller <- function(subject, query) {
      if (subject == 'A' || subject == 'T') {
          if (query == 'C' || query == 'G' ) {
              'strong'
          } else {
              'weak'
          }
      } else {
          if (query == 'A' || query == 'G') {
              'weak'
          } else {
              'strong'
          }
      }
  }

  ## on applique la fonction rowwise, ie ligne par ligne, via `mutate`, puis on
  ## dégroupe.
  snp_data %>%
      rowwise() %>%
      mutate(mutation_type = mutant_caller(s_base, q_base)) %>%
      ungroup() ->
      snp_data
  ## conversion en facteur
  snp_data$mutation_type = factor(snp_data$mutation_type)


  ## distribution des SNP
  ## facétée par type de mutant, couleur = type de mutation
  mutation_plot <- ggplot(data = snp_data, aes(offset_on_subject)) +
      geom_histogram(aes(fill = mutation_type), binwidth = 10, position = "dodge") +
      facet_grid(~mutant, labeller = label_both) +
      theme_minimal(base_family = "Courier") +
      ## scale_y_tufte() +
      scale_x_continuous(breaks = seq(1, 734, 60)) +
      scale_fill_brewer(palette = "Set2",
                        name = "Type de mutation",
                        labels = c("AT -> GC", "GC -> AT")) +
      xlab("Distribution des SNP sur le gene sauvage") +
      ylab("") +
      theme(panel.ontop = TRUE,
            legend.position = c(0.6, 0.6),
            axis.text = element_text(size = 8, colour = "gray"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor.x = element_blank(),
            panel.grid.minor.y = element_blank(),
            panel.grid.major.y = element_line(colour = "white", size = 1)) 

  ## distribution des SNP
  ## facetée par type de mutation, couleur : type de mutant. 
  muttype_plot <- ggplot(data = snp_data, aes(offset_on_subject)) +
      geom_histogram(aes(fill = mutant), binwidth = 10, position = "dodge") +
      facet_grid(~mutation_type, labeller = label_both) +
      theme_minimal(base_family = "Courier") +
      ## scale_y_tufte() +
      scale_x_continuous(breaks = seq(1, 734, 60)) +
      scale_fill_brewer(palette = "Dark2",
                        name = "Type de mutant",
                        labels = c("mutant strong", "mutant weak")) +
      xlab("Distribution des SNP sur le gene sauvage") +
      ylab("") +
      theme(panel.ontop = TRUE,
            legend.position = c(0.6, 0.6),
            axis.text = element_text(size = 8, colour = "gray"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor.x = element_blank(),
            panel.grid.minor.y = element_blank(),
            panel.grid.major.y = element_line(colour = "white", size = 1)) 

  ##==============================================================================
  ## SAVE PLOTS
  ##==============================================================================
  save_to_a5 <- function(output_file, plot)
  {
      pdf(file = output_file, height = 5.8, width = 8.3)
      print(plot)
      dev.off()
  }

  save_to_a3 <- function(output_file, plot)
  {
                                          # a3 dimensions : 11.69in x 16.53in
      pdf(file = output_file, height = 11.69, width = 16.53)
      print(plot)
      dev.off()
  }

  save_to_a5(output_file = "../../analysis/substitution_distribution.pdf",
             plot = mutation_plot)
  save_to_a5(output_file = "../../analysis/snp_distribution.pdf",
             plot = snp_plot)
  save_to_a5(output_file = "../../analysis/muttype_plot.pdf",
             plot = muttype_plot)

  multi_plot <- plot_grid(snp_plot, mutation_plot, NULL, muttype_plot, ncol = 2, labels = c("A", "B", " ", "C"))

  pdf(file = "../../analysis/snp_resume.pdf", height = 11.69, width = 16.53)
  multi_plot
  dev.off()

  ##==============================================================================
  ## SWITCH INITIAL
  ##==============================================================================
  snp_data %>%
      group_by(name, mutation_type) %>%
      summarise(switch_pos = min(offset_on_subject)) ->
      switch_data_muttype

  ## la position de switch sans tenir compte de la qualité des mutants
  switch_position_globale <- ggplot(switch_data_muttype, aes(switch_pos)) +
      geom_histogram(fill = "black", binwidth = 5) +
      theme_minimal(base_family = "Courier") +
      xlab("") +
      ylab("") +
      annotate("rect", xmin = 160, xmax = 260, ymin = 0, ymax = 10, alpha = 0.4) + 
      annotate("text", x = 220, y = 13, label = "coldspot?", size = 2,  alpha = 0.5) + 
      annotate("rect", xmin = 480, xmax = 620, ymin = 0, ymax = 10, alpha = 0.4) + 
      annotate("text", x = 550, y = 13, label = "coldspot?", size = 2,  alpha = 0.5) + 
      mytheme
  switch_position_globale
  ggsave(switch_position_globale, file = "../../analysis/switch_position_globale.pdf",
         height = 4, width = 7, units = "cm")

  ## en tenant compte du type de mutation
  switch_pos_by_muttype <- ggplot(switch_data_muttype, aes(switch_pos)) +
      geom_histogram(aes(fill = mutation_type),
                     position = "dodge", 
                     binwidth = 10) +
      scale_x_continuous(breaks = seq(1, 734, 30)) +
      theme_minimal(base_family = "Courier") +
      scale_fill_discrete() +
      xlab("Distribution de la qualite de la premiere substitution") +
      ylab("") +
      theme(legend.position = c(0.8, 0.7)) +
      mytheme
  switch_pos_by_muttype
  ## en tenant compte du type de mutant
  snp_data %>%
      group_by(name, mutant) %>%
      summarise(switch_pos = min(offset_on_subject)) ->
      switch_data_mutant
  switch_pos_by_mutant <- ggplot(switch_data_mutant, aes(switch_pos)) +
      geom_histogram(aes(fill = mutant),
                     position = "dodge", 
                     binwidth = 10) +
      ## facet_grid(.~mutant) +
      scale_x_continuous(breaks = seq(1, 734, 30)) +
      theme_minimal(base_family = "Courier") +
      scale_fill_discrete() +
      xlab("Distribution de la position de switch en fonction du type de mutant") +
      ylab("") +
      theme(legend.position = c(0.8, 0.5)) +
      mytheme
  switch_pos_by_mutant
  multi_switch_plot <- plot_grid(switch_pos_by_muttype, switch_pos_by_mutant, ncol = 1, labels = c("A", "B"))
  ggsave(multi_switch_plot, file = "../../analysis/switch_pos_by_mutant.pdf",
         height = 21, width = 29.7, units = "cm")

  ##==============================================================================
  ## SWITCH TERMINAL
  ##==============================================================================
  snp_data %>%
      group_by(name, mutant) %>%
      summarise(switch_pos = max(offset_on_subject)) ->
      end_data_mutant

  pdf(file = "../../analysis/end_switch.pdf")
  print(
      ggplot(end_data_mutant, aes(switch_pos)) +
      geom_histogram(aes(fill = mutant),
                     position = "dodge",
                     binwidth = 1) +
      theme_minimal() +
      xlab("") + ylab("") +
      theme(legend.position = c(0.4, 0.5)) +
      mytheme
  )
  dev.off()
#+END_SRC
